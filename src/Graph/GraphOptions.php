<?php

namespace SRF\Graph;

use ParamProcessor\ParameterTypes;

/**
 * Represents a set of options for the Graph Printer
 *
 *
 * @license GPL-2.0-or-later
 * @since 3.2
 *
 * @author Sebastian Schmid (gesinn.it)
 *
 */

class GraphOptions {
	// Arrow directions.
	/** @const int DIR_NONE */
	public const DIR_NONE = 0;
	/** @const int DIR_PARENT */
	public const DIR_PARENT = 1;
	/** @const int DIR_CHILD */
	public const DIR_CHILD = 2;

	/** @var string $graphName Will be shown as Graph label, if graphlabel = yes. */
	private $graphName;
	/** @var string $layout Graph layout. dot, sdf, etc. */
	private $layout;
	/** @var string[] $nodeLabels A set of printout labels that should be used as labels for the owning nodes. */
	private $nodeLabels;
	/** @var string $wordWrapLimit Maximum line length not requiring word-wrapping. */
	private $wordWrapLimit;
	/** @var int $parentRelation 0 for agraphs, 1 for property -> page, 2 for page -> property (default). */
	private $parentRelation;
	/** @var string $enableGraphLink Whether to add wikilinks to nodes, edges and non-page property labels. */
	private $enableGraphLink;
	/** @var string $showGraphColor Whether to apply colors to graph. */
	private $showGraphColor;
	/** @var string $showGraphLegend Whether to add an HTML legend to the graph. */
	private $showGraphLegend;
	/** @var bool $showDotLegend Show a legend generated by GraphViz. */
	private $showDotLegend;
	/** @var bool $showGraphFields Show non-Page properties as fields within nodes rather than edges. */
	private $showGraphFields;
	/** @var bool $oblique Try to start edges and place fields at their owner nodes. */
	private $oblique;

	/** @var array[] $attributes A 2D array of graph attributes. */
	private $attributes = [ 'graph' => [], 'cluster' => [], 'node' => [], 'edge' => [] ];

	/**
	 * @param array $options
	 */
	public function __construct( array $options ) {
		$allowed = GraphPrinter::allowedAttributes();
		$contexts = implode( '|', array_keys( $this->attributes ) ); // 'graph|cluster|node|edge'.
		foreach ( $options as $name => $option ) {
			if (
				$option &&
				preg_match( "/^(?<context>$contexts)(?<attr>.+)$/", $name, $match ) &&
				in_array( $match['attr'], $allowed[$match['context']], true )
			) {
				// If the option name is prefixed with context, and it is allowed by GraphViz.
				$this->attributes[$match['context']][$match['attr']] = $option;
			}
		}

		$this->graphName = $options['graphname'];
		if ( $options['graphlabel'] ) {
			$this->attributes['graph']['label'] = $this->graphName;
		}
		$this->layout = trim( $options['graphlayout'] );
		$this->nodeLabels = $options['labelproperty'];
		$this->parentRelation = [
			'none' => self::DIR_NONE, 'parent' => self::DIR_PARENT, 'child' => self::DIR_CHILD
		][strtolower( $options['relation'] )];
		$this->wordWrapLimit = $options['wordwraplimit'];
		$this->enableGraphLink = $options['graphlink'];
		$this->showGraphColor = $options['graphcolor'];
		$this->showGraphLegend = $options['graphlegend'];
		$this->showDotLegend = $options['dotlegend'];
		$this->showGraphFields = $options['graphfields'];
		$this->oblique = $options['graphoblique'];
	}

	public function getGraphName(): string {
		return $this->graphName;
	}

	/**
	 * Get printout labels that should be used as node labels by the owning nodes.
	 * @return string[]
	 */
	public function getNodeLabels(): array {
		return $this->nodeLabels;
	}

	/**
	 * Lines longer than that will be word-wrapped.
	 * @return int
	 */
	public function getWordWrapLimit(): int {
		return $this->wordWrapLimit;
	}

	/**
	 * 0 for page -- property, 1 for property -> page, 2 for page -> property (default).
	 * @return int
	 */
	public function getParentRelation(): int {
		return $this->parentRelation;
	}

	/**
	 * Whether to add wikilinks to nodes and links to properties to edges and field labels.
	 * @return bool
	 */
	public function isGraphLink(): bool {
		return $this->enableGraphLink;
	}

	/**
	 * Whether to apply user-supplied or automatically selected from the palette colors to nodes and edges.
	 * @return bool
	 */
	public function isGraphColor(): bool {
		return $this->showGraphColor;
	}

	/**
	 * Whether to show HTML legend below the graph.
	 * @return bool
	 */
	public function isGraphLegend(): bool {
		return $this->showGraphLegend;
	}

	/**
	 * Whether to show a legend rendered by GraphViz below the graph.
	 * @return bool
	 */
	public function isDotLegend(): bool {
		return $this->showDotLegend;
	}

	/**
	 * Whether to show non-page properties on their owners' nodes rather than as edges and separate nodes.
	 * @return bool
	 */
	public function showGraphFields(): bool {
		return $this->showGraphFields;
	}

	/**
	 * Try to start edges and place fields at their owner nodes.
	 * @return bool
	 */
	public function isOblique(): bool {
		return $this->oblique;
	}

	/**
	 * Which engine to use to render the graph: dot, neato, etc.
	 * @return string
	 */
	public function getLayout(): string {
		return $this->layout;
	}

	/**
	 * Get color scheme for nodes or edges.
	 * @param string $context 'node' or 'edge'
	 * @return string
	 */
	public function getColorScheme( string $context ): string {
		return $this->attributes[$context]['colorscheme'] ?? 'X11';
	}

	/**
	 * Return the attributes of graph objects (graph, nodes, edges, clusters as an associative array.
	 * @return array[]
	 */
	public function getAllAttributes(): array {
		return $this->attributes;
	}

	/**
	 * Return GraphViz attributes converted to parser function parameters.
	 * @return array[]
	 * @throws \JsonException
	 */
	public static function getGraphVizAttributes(): array {
		// Backward compatibility.
		$overrides = [
			'graphrankdir' => [ 'aliases' => [ 'arrowdirection' ], 'default' => 'LR' ],
			'graphlayout' => [ 'default' => 'dot' ],
			'graphcolor' => [ 'type' => 'boolean', 'default' => false, 'redefined' => true ],
			'graphlabel' => [ 'redefined' => true ]
		];

		$types = json_decode( file_get_contents( __DIR__ . '/specs/types.json' ), true, 4, JSON_THROW_ON_ERROR );
		$standardTypes = ParameterTypes::getCoreTypes();
		$attrs = json_decode( file_get_contents( __DIR__ . '/specs/attributes.json' ), true, 5, JSON_THROW_ON_ERROR );
		unset( $attrs['__comment'] );
		$params = [];
		foreach ( $attrs as $attr => $spec ) {
			$settings = [ 'default' => false, 'trim' => true ];
			if ( count( $spec['types'] ) === 1 ) {
				$settings['type'] = $spec['types'][0];
			}
			if ( isset( $settings['type'] ) && !isset( $standardTypes[$settings['type']] ) ) {
				$type = $types[$settings['type']];
				if ( isset( $type['regex'] ) ) {
					$settings['regex'] = '/^' . $type['regex'] . '$/';
				}
				if ( isset( $type['values'] ) ) {
					$settings['values'] = $type['values'];
				}
				$settings['type'] = 'string';
			}
			foreach ( $spec['used_by'] ?? [] as $user ) {
				$name = "$user$attr";
				if ( isset( $aliases[$name] ) ) {
					$settings['aliases'] = $aliases[$name];
				}
				if ( count( $spec['used_by'] ) === 1 ) {
					// The attribute is relevant for only one context, so, allow a prefixless alias.
					$settings['aliases'] = $settings['aliases'] ?? [];
					$settings['aliases'][] = $attr;
				}
				if ( !( ( $overrides[$name] ?? [] )['redefined'] ?? false ) ) {
					// Some GraphViz attributes are set by SMW query,
					// or their names have been previously redefined by the SRF graphviz format.
					$params[$name] = ($overrides[$name] ?? []) + $settings;
					GraphPrinter::addAttribute( $user, $attr );
				}
			}
		}
		return $params;
	}
}
